---
layout: post
title: Breadth First Search
tags:
  - algo-vis
hero: https://images.unsplash.com/photo-1580706483913-b6ea7db483a0?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1237&q=80
published: true
---

This post is part of [a series](/tag/algo-vis/) explaining algorithms. You can visualise BFS using [Algorithm Visualiser](https://algovis.andcov.dev).

Breadth-First Search (**BFS**) is a fundamental algorithm used to iterate over the vertices of a graph in a specific order. It starts at a given vertex and proceeds by visiting all of its neighbours, then by visiting all of the neighbours of the neighbours, and so on.
<!–-break-–>

![]({{ "/uploads/ezgifcom-gif-maker.gif" | relative_url }})
As you can see in the animation, the nodes visited by BFS can look like an expanding circle, peeling off all the vertices that are situated at an equal distance from the starting vertex at a time.

# Algorithm

BFS is implemented using a queue. Your code might look something like this:

<script src="https://gist.github.com/andcov/961711ee2c6b7701a33a056e293c7910.js"></script>

It initialises the queue with the starting vertex, then, while the queue is not empty, it gets the first element from the queue and adds all of its unvisited neighbours to the queue.

### Running time

Since it visits every vertex exactly once and it looks at every edge at most two times, BFS runs in linear time: $$O(\vert V \vert + \vert E \vert)$$.

# Shortest Paths

An emerging property of this algorithm is that it computes shortest paths between the start vertex and all other vertices. All we have to do is to keep track of the vertices we have visited so far for each vertex.

To prove that BFS does indeed compute shortest paths, let's assume we reach a visited vertex. Since the algorithm visits the vertices sequentially, this vertex can only be marked as visited if there already exists a shorter path between it and the start vertex. In other words, marking a vertex as visited means this is the first time we see it, so we must have taken the shortest path to get to it, otherwise, we would have already found it as visited. Anyhow, this means that BFS computes shortest paths in linear time, which is a great achievement for such a simple and short algorithm!

As exciting as this discovery might be, BFS does have a major drawback: it does not take into account the weight of the edges.
{: .notice-alert}

In order to get these paths, we must store some additional information. For each vertex, we must store a reference to the previous vertex in the path. For example, in the animation from above, vertex 6 stores a reference to vertex 2. Vertex 2 stores a referance to vertex 0. So if we want to get the shortest path from 6 to the start vertex, we just follow this link of references and get 6-2-0.

If you want the shortest distance to a specific vertex, you can simply check if the current vertex is the desired one and halt if that is the case.

# Algorithm Visualiser

You can use [Algorithm Visualiser](https://algovis.andcov.dev) to get a better feeling for how BFS works. For starters, do not modify the board at all and just run BFS. You will see an expanding square, similar to how the animation from above uses an expanding circle. You can add some walls and see how the algorithm reacts.

Also, try putting some heavy or light cells along the path the algorithm takes. You will see that BFS does not care about them because, as stated, BFS does not take weights into account. This might seem like a big disadvantage, but look at the `Stats` tab, particularly at the number of operations. Now, run Bellman-Ford on the same board and compare how many operations it requires. For sure, the number will be greater. The price for taking weights into account is paid in the running time of the algorithm.