---
layout: post
title: Dijkstra's Shortest Path Algorithm
tags:
  - algo-vis
  - com-sci
hero: https://images.unsplash.com/photo-1580706483913-b6ea7db483a0?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1237&q=80
published: true
---

This post is part of [a series](/tag/algo-vis/) explaining algorithms. You can visualise Dijkstra using [Algorithm Visualiser](https://algovis.andcov.dev).

Dijkstra's Shortest Path Algorithm (I will simply refer to it as **Dijkstra**) is the father of all Shortest Path Algorithms. Using a heap data structure, it computes the shortest path from a start vertex to all other vertices blazingly fast.
<!–-break-–>

# Algorithm

The basic implementation of Dijkstra (not using heaps) might look something like this:

<script src="https://gist.github.com/andcov/21ddb516ae030d1fd9d88a8fc1c60904.js"></script>

## Explanation

![]({{ "uploads/algo-vis/dijkstra-animation.gif" | relative_url }})

We will use a set, call it $$X$$, containing the vertices we have already processed (this is the grey region in the animation). By processed I mean that we have computed their shortest paths. We store the length of these shortest paths in an array, call it $$A$$ (i.e. $$A[v]$$ is the length of the shortest path from the start vertex to $$v$$). Initially, $$X$$ will only contain the starting vertex. The length of the shortest path from the start vertex to itself is 0. Next, we want to find the edge that satisfies the following relation:


$$\min_{(v, w) \in E,\, v \in X \, \land \, w \notin X} A[v] + w_{vw}$$


Don't worry if this looks menacing, all it's saying is: "I want to find an edge of the graph with its tail in $$X$$ and its head not in $$X$$, such that the cost of going from the start vertex, via this path, to the head vertex is minimum". In other words, we are looking for the closest vertex to the start vertex that we haven't already processed. This becomes apparent when looking at the animation. The grey region always swallows the closest vertex that has not been processed so far.

After we find this edge, we add the head vertex $$w$$ to $$X$$ (this is when the grey region swallows a vertex) and set $$A[w] := A[v] + w_{vw}$$.

The final distances can be found in $$A$$, but if you want to also get the shortest path, not only its weight, then you can use the same technique we employed with BFS (i.e. for each vertex, store the previous vertex in the shortest path).

## Proof
I will not present the full proof here, but the idea is that we use induction. If we have computed the paths correctly up to some point and now we want to add $$w$$ to $$X$$, we can prove that the path we use for $$w$$ is the shortest. If you want to try to prove this for yourself, this image might help you:
![]({{ "uploads/algo-vis/dijkstra-graph-path.png" | relative_url }})

Dijkstra is usually the best algorithm for finding the shortest paths from the start vertex to all other vertices, however, it does have one issue: it does not work if you use negative weights (in the proof, we assume that, as we go further, paths have greater weights, but that is not the case if we allow negative edge weights).
{: .notice-alert}

## Running time
The basic implementation presented above does not have the best running time ($$O(|V|^2)$$), but this can be improved drastically by using a heap. This way, we can get a running time of $$O(|E|\log |V|)$$ (and an even better $$O(|E| + |V|\log |V|)$$ for sparse graphs). If you have no idea what these symbols mean, look into [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation) and [graph theory](https://en.wikipedia.org/wiki/Graph_theory).

# Algorithm Visualiser
If you want to play around with Dijkstra, try the [Algorithm Visualiser](https://algovis.andcov.dev). First, run BFS, and then Dijkstra. You will see that the blue cells make a very similar pattern in both cases. This will also be true (more or less) if you add walls.

The cool part comes when you add weights and feathers ([read this](/posts/algo-vis) if you don't know how to do that). BFS does not care about the weight of the edges, so it will just go through heavy cells as if they were not there and it won't take advantage of light cells. This is not the case with Dijkstra. Try placing a few light cells in a line, and the algorithm will dash through those cells first, prioritising them over normal or heavy ones. If you place some heavy cells, the algorithm will avoid them. It will return to them, but only after exploring in all other directions.

If you look at the `Stats` tab when running BFS, and then when running Dijkstra, you will see that BFS is indeed a faster algorithm (this is clear if you know the running times of the algorithms). However, Dijkstra is not far behind and considering it takes weights into account, it is a marvelous algorithm.