---
layout: post
title: Dijkstra's Shortest Path Algorithm
tags:
  - algo-vis
hero: https://images.unsplash.com/photo-1580706483913-b6ea7db483a0?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1237&q=80
published: false
---

This post is part of [a series](/tag/algo-vis/) explaining algorithms. You can visualise Dijkstra using [Algorithm Visualiser](https://algovis.andcov.dev).

Dijkstra's Shortest Path Algorithm (I will simply refer to it as **Dijkstra**) is the father of all Shortest Path Algorithms. Using a heap data structure, it computes the shortest path from a start vertex to all other vertices blazingly fast.
<!–-break-–>

# Algorithm

The basic implementation of Dijkstra (not using heaps) might look somthing like this:

<script src="https://gist.github.com/andcov/21ddb516ae030d1fd9d88a8fc1c60904.js"></script>

Dijkstra is what's called a greedy algorithm. This basically means that at each stage of the algorithm, we make a choice based on some citeria and hope that it will lead us to the right solution. This obviously does not work for all problems, but shortest paths is one of it's applications.

We will use a set, call it $$X$$, containing the vertices we have already processed. By processed I mean that we have computed their shortest paths. We store the length of these shortest paths in an array, call it $$A$$ (i.e. $$A[v]$$ is the length of the shortest path from the start vertex to $$v$$). Initially, $$X$$ will only contain the starting vertex. The length of the shortest path from the start vertex to itself is 0. Next, we want to find the edge that satisfies the following relation:


$$\min_{(v, w) \in E,\, v \in X \, \land \, w \notin X} A[v] + w_{vw}$$


Don't worry if this look menacing, all it's saying is: "I want to find an edge of the graph with its tail in $$X$$ and its head not in $$X$$, such that the cost of going from the start vertex, via this path, to the head vertex is minimum". In other words, we are looking for the closest vertex to the start vertex that we haven't already processed.

After we find this edge, we add the head vertex $$w$$ to $$X$$ and set $$A[w] := A[v] + w_{vw}$$.

This was the greedy citerium I was talking about earlier. We are basically saying: "At this point in time, having knowledge only about the edges and vertices I have encounterd so far, it looks like this is the best solution, so I'm going to assume that it actually is the global, optimal solution (for the current vertex). If it turns out that it's not the optimal one, well, too bad...". The power of Dijkstra is that, if the edges have only positive weights, it never gets to the "well, too bad..." case.





